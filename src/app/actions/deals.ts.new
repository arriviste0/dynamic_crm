'use server';

import clientPromise from '@/lib/mongodb';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { ObjectId } from 'mongodb';
import { BaseEntity, CustomField } from '@/lib/types';

interface Deal extends BaseEntity {
    dealName: string;
    companyName: string;
    amount: string;
    stage: 'Prospect' | 'Qualifying' | 'Proposal' | 'Negotiation' | 'Closed Won';
}

const dealSchema = z.object({
    dealName: z.string().min(2, 'Deal name must be at least 2 characters.'),
    companyName: z.string().min(2, 'Company name must be at least 2 characters.'),
    amount: z.string().min(1, 'Amount is required'),
    stage: z.enum(['Prospect', 'Qualifying', 'Proposal', 'Negotiation', 'Closed Won']),
    fieldOrder: z.array(z.string()).optional(),
});

export async function getDeals() {
    try {
        const client = await clientPromise;
        const db = client.db();

        const deals = await db.collection('deals').find({}).toArray();

        return {
            success: true,
            data: deals.map(deal => ({
                ...deal,
                _id: deal._id.toString()
            }))
        };
    } catch (error) {
        console.error('Error fetching deals:', error);
        return { success: false, message: 'Failed to fetch deals' };
    }
}

export async function createDeal(data: any) {
    try {
        const client = await clientPromise;
        const db = client.db();

        // Validate the base deal data
        const validation = dealSchema.safeParse(data);
        
        if (!validation.success) {
            return { 
                success: false, 
                message: 'Invalid data.', 
                errors: validation.error.flatten().fieldErrors 
            };
        }

        // Get custom fields for deals
        const customFields = await db.collection('customFields')
            .find({ module: 'deals' })
            .toArray();

        // Extract custom field values
        const customFieldValues = customFields.reduce((acc: any, field) => {
            acc[field.name] = data[field.name] || '';
            return acc;
        }, {});

        // Prepare deal data
        const dealData = {
            ...validation.data,
            customFields: customFieldValues,
            createdAt: new Date(),
            updatedAt: new Date(),
        };

        // Insert the deal
        const result = await db.collection('deals').insertOne(dealData);

        revalidatePath('/sales-pipeline');
        revalidatePath('/'); // Revalidate dashboard

        return {
            success: true,
            data: {
                _id: result.insertedId.toString(),
                ...dealData
            }
        };

    } catch (error) {
        console.error('Error creating deal:', error);
        return { success: false, message: 'Failed to create deal' };
    }
}

export async function updateDeal(id: string, data: any) {
    try {
        const client = await clientPromise;
        const db = client.db();

        const validation = dealSchema.safeParse(data);
        
        if (!validation.success) {
            return { 
                success: false, 
                message: 'Invalid data.', 
                errors: validation.error.flatten().fieldErrors 
            };
        }

        const customFields = await db.collection('customFields')
            .find({ module: 'deals' })
            .toArray();

        const customFieldValues = customFields.reduce((acc: any, field) => {
            acc[field.name] = data[field.name] || '';
            return acc;
        }, {});

        const dealData = {
            ...validation.data,
            customFields: customFieldValues,
            updatedAt: new Date(),
        };

        await db.collection('deals').updateOne(
            { _id: new ObjectId(id) },
            { $set: dealData }
        );

        revalidatePath('/sales-pipeline');
        revalidatePath('/');

        return { success: true };
    } catch (error) {
        console.error('Error updating deal:', error);
        return { success: false, message: 'Failed to update deal' };
    }
}

export async function deleteDeal(id: string) {
    try {
        const client = await clientPromise;
        const db = client.db();
        
        await db.collection('deals').deleteOne({ 
            _id: new ObjectId(id) 
        });

        revalidatePath('/sales-pipeline');
        revalidatePath('/');

        return { success: true };
    } catch (error) {
        console.error('Error deleting deal:', error);
        return { success: false, message: 'Failed to delete deal' };
    }
}
